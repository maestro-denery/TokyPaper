From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Owen1212055 <23108066+Owen1212055@users.noreply.github.com>
Date: Wed, 6 Jul 2022 23:00:36 -0400
Subject: [PATCH] Paper Plugins


diff --git a/build.gradle.kts b/build.gradle.kts
index 0660174a8c543b3e8ef317cfabcda88a6a53d844..9330ca21acf6f6a0e4caa6cc619d760aafc3a605 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -46,7 +46,7 @@ dependencies {
     implementation("org.ow2.asm:asm-commons:9.2")
     // Paper end

-    compileOnly("org.apache.maven:maven-resolver-provider:3.8.5")
+    api("org.apache.maven:maven-resolver-provider:3.8.5") // Paper, expose
     compileOnly("org.apache.maven.resolver:maven-resolver-connector-basic:1.7.3")
     compileOnly("org.apache.maven.resolver:maven-resolver-transport-http:1.7.3")
     compileOnly("com.google.code.findbugs:jsr305:1.3.9") // Paper
diff --git a/src/main/java/com/destroystokyo/paper/utils/PaperPluginLogger.java b/src/main/java/com/destroystokyo/paper/utils/PaperPluginLogger.java
index 76f2cb9cd99cad2a9484eab2becd8c36f1dd91b3..9be4ef5c56c243c2c112e4a80058cddcfb5b6215 100644
--- a/src/main/java/com/destroystokyo/paper/utils/PaperPluginLogger.java
+++ b/src/main/java/com/destroystokyo/paper/utils/PaperPluginLogger.java
@@ -1,5 +1,6 @@
 package com.destroystokyo.paper.utils;

+import io.papermc.paper.plugin.configuration.PluginConfiguration;
 import org.bukkit.plugin.PluginDescriptionFile;

 import java.util.logging.Level;
@@ -24,8 +25,21 @@ public class PaperPluginLogger extends Logger {
         return logger;
     }

-    private PaperPluginLogger(@NotNull PluginDescriptionFile description) {
-        super(description.getPrefix() != null ? description.getPrefix() : description.getName(), null);
+    // TODO
+    @NotNull
+    public static Logger getLogger(@NotNull PluginConfiguration configuration) {
+        Logger logger = new PaperPluginLogger(configuration);
+        if (!LogManager.getLogManager().addLogger(logger)) {
+            // Disable this if it's going to happen across reloads anyways...
+            //logger.log(Level.WARNING, "Could not insert plugin logger - one was already found: {}", LogManager.getLogManager().getLogger(this.getName()));
+            logger = LogManager.getLogManager().getLogger(configuration.getLoggingPrefix() != null ? configuration.getLoggingPrefix() : configuration.getIdentifier());
+        }
+
+        return logger;
+    }
+
+    private PaperPluginLogger(@NotNull PluginConfiguration description) {
+        super(description.getLoggingPrefix() != null ? description.getLoggingPrefix() : description.getIdentifier(), null);
     }

     @Override
diff --git a/src/main/java/io/papermc/paper/plugin/PermissionManager.java b/src/main/java/io/papermc/paper/plugin/PermissionManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..a804eb62aaa88bd6d6586cdc27c0f6a6f62f75db
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/PermissionManager.java
@@ -0,0 +1,165 @@
+package io.papermc.paper.plugin;
+
+import org.bukkit.permissions.Permissible;
+import org.bukkit.permissions.Permission;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+import java.util.Set;
+
+public interface PermissionManager {
+
+    /**
+     * Gets a {@link Permission} from its fully qualified name
+     *
+     * @param name Name of the permission
+     * @return Permission, or null if none
+     */
+    @Nullable
+    Permission getPermission(@NotNull String name);
+
+    /**
+     * Adds a {@link Permission} to this plugin manager.
+     * <p>
+     * If a permission is already defined with the given name of the new
+     * permission, an exception will be thrown.
+     *
+     * @param perm Permission to add
+     * @throws IllegalArgumentException Thrown when a permission with the same
+     *                                  name already exists
+     */
+    void addPermission(@NotNull Permission perm);
+
+    /**
+     * Removes a {@link Permission} registration from this plugin manager.
+     * <p>
+     * If the specified permission does not exist in this plugin manager,
+     * nothing will happen.
+     * <p>
+     * Removing a permission registration will <b>not</b> remove the
+     * permission from any {@link Permissible}s that have it.
+     *
+     * @param perm Permission to remove
+     */
+    void removePermission(@NotNull Permission perm);
+
+    /**
+     * Removes a {@link Permission} registration from this plugin manager.
+     * <p>
+     * If the specified permission does not exist in this plugin manager,
+     * nothing will happen.
+     * <p>
+     * Removing a permission registration will <b>not</b> remove the
+     * permission from any {@link Permissible}s that have it.
+     *
+     * @param name Permission to remove
+     */
+    void removePermission(@NotNull String name);
+
+    /**
+     * Gets the default permissions for the given op status
+     *
+     * @param op Which set of default permissions to get
+     * @return The default permissions
+     */
+    @NotNull
+    Set<Permission> getDefaultPermissions(boolean op);
+
+    /**
+     * Recalculates the defaults for the given {@link Permission}.
+     * <p>
+     * This will have no effect if the specified permission is not registered
+     * here.
+     *
+     * @param perm Permission to recalculate
+     */
+    void recalculatePermissionDefaults(@NotNull Permission perm);
+
+    /**
+     * Subscribes the given Permissible for information about the requested
+     * Permission, by name.
+     * <p>
+     * If the specified Permission changes in any form, the Permissible will
+     * be asked to recalculate.
+     *
+     * @param permission  Permission to subscribe to
+     * @param permissible Permissible subscribing
+     */
+    void subscribeToPermission(@NotNull String permission, @NotNull Permissible permissible);
+
+    /**
+     * Unsubscribes the given Permissible for information about the requested
+     * Permission, by name.
+     *
+     * @param permission  Permission to unsubscribe from
+     * @param permissible Permissible subscribing
+     */
+    void unsubscribeFromPermission(@NotNull String permission, @NotNull Permissible permissible);
+
+    /**
+     * Gets a set containing all subscribed {@link Permissible}s to the given
+     * permission, by name
+     *
+     * @param permission Permission to query for
+     * @return Set containing all subscribed permissions
+     */
+    @NotNull
+    Set<Permissible> getPermissionSubscriptions(@NotNull String permission);
+
+    /**
+     * Subscribes to the given Default permissions by operator status
+     * <p>
+     * If the specified defaults change in any form, the Permissible will be
+     * asked to recalculate.
+     *
+     * @param op          Default list to subscribe to
+     * @param permissible Permissible subscribing
+     */
+    void subscribeToDefaultPerms(boolean op, @NotNull Permissible permissible);
+
+    /**
+     * Unsubscribes from the given Default permissions by operator status
+     *
+     * @param op          Default list to unsubscribe from
+     * @param permissible Permissible subscribing
+     */
+    void unsubscribeFromDefaultPerms(boolean op, @NotNull Permissible permissible);
+
+    /**
+     * Gets a set containing all subscribed {@link Permissible}s to the given
+     * default list, by op status
+     *
+     * @param op Default list to query for
+     * @return Set containing all subscribed permissions
+     */
+    @NotNull
+    Set<Permissible> getDefaultPermSubscriptions(boolean op);
+
+    /**
+     * Gets a set of all registered permissions.
+     * <p>
+     * This set is a copy and will not be modified live.
+     *
+     * @return Set containing all current registered permissions
+     */
+    @NotNull
+    Set<Permission> getPermissions();
+
+    /**
+     * Adds a list of permissions.
+     * <p>
+     * This is meant as an optimization for adding multiple permissions without recalculating each permission.
+     *
+     * @param perm permission
+     */
+    void addPermissions(@NotNull List<Permission> perm);
+
+    /**
+     * Clears the current registered permissinos.
+     * <p>
+     * This is used for reloading.
+     */
+    void clearPermissions();
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/UnsupportedBukkitPluginLoader.java b/src/main/java/io/papermc/paper/plugin/UnsupportedBukkitPluginLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..aab8e324b4638357d9aaeadf17da5e5f2b82ce35
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/UnsupportedBukkitPluginLoader.java
@@ -0,0 +1,45 @@
+package io.papermc.paper.plugin;
+
+import org.bukkit.event.Event;
+import org.bukkit.event.Listener;
+import org.bukkit.plugin.*;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.File;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Pattern;
+
+public enum UnsupportedBukkitPluginLoader implements PluginLoader {
+    INSTANCE;
+
+    @Override
+    public @NotNull Plugin loadPlugin(@NotNull File file) throws InvalidPluginException, UnknownDependencyException {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public @NotNull PluginDescriptionFile getPluginDescription(@NotNull File file) throws InvalidDescriptionException {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public @NotNull Pattern[] getPluginFileFilters() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public @NotNull Map<Class<? extends Event>, Set<RegisteredListener>> createRegisteredListeners(@NotNull Listener listener, @NotNull Plugin plugin) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void enablePlugin(@NotNull Plugin plugin) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void disablePlugin(@NotNull Plugin plugin) {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrap.java b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrap.java
new file mode 100644
index 0000000000000000000000000000000000000000..721cdeacdbc74c23811fc0119e213e1d8df92275
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrap.java
@@ -0,0 +1,36 @@
+package io.papermc.paper.plugin.bootstrap;
+
+import io.papermc.paper.plugin.provider.util.ProviderUtil;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A plugin boostrap is meant for loading certain parts of the plugin before the server is loaded.
+ * <p>
+ * Plugin bootstrapping allows values to be initialized in certain parts of the server that might not be allowed
+ * when the server is running.
+ * <p>
+ * Your bootstrap class will be on the same classloader as your JavaPlugin.
+ * <p>
+ * <b>All calls to Bukkit may throw a NullPointerExceptions or return null unexpectedly. You should only call api methods that are explicitly documented to work in the bootstrapper</b>
+ */
+public interface PluginBootstrap {
+
+    /**
+     * Called by the server, allowing you to bootstrap with context that provides things like a logger and your shared plugin configuration file.
+     *
+     * @param context server provided context
+     */
+    void boostrap(@NotNull PluginBootstrapContext context);
+
+    /**
+     * Called by the server, allows you to create your own java plugin instance inorder to do things such as
+     * pass objects through the constructor.
+     * @param context server created bootstrap object
+     * @return java plugin instance
+     */
+    @NotNull
+    default JavaPlugin createPlugin(@NotNull PluginBootstrapContext context) {
+        return ProviderUtil.loadClass(context.getConfiguration().getMain(), JavaPlugin.class, this.getClass().getClassLoader());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrapContext.java b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrapContext.java
new file mode 100644
index 0000000000000000000000000000000000000000..732d59c2f176f8ad80908db4d224cfb271f9d1e1
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrapContext.java
@@ -0,0 +1,46 @@
+package io.papermc.paper.plugin.bootstrap;
+
+import io.papermc.paper.plugin.configuration.PluginConfiguration;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.nio.file.Path;
+import java.util.logging.Logger;
+
+/**
+ * Contains context used for when a plugin's bootstrap class is executed.
+ */
+@ApiStatus.NonExtendable
+public interface PluginBootstrapContext {
+
+    /**
+     * Gets the plugin's configuration.
+     * @return configuration
+     */
+    @NotNull
+    PluginConfiguration getConfiguration();
+
+    /**
+     * Gets the path to the data directory for the plugin.
+     *
+     * @return plugin
+     */
+    @NotNull
+    Path getDataDirectory();
+
+    /**
+     * Gets the configuration file for this plugin.
+     *
+     * @return configuration file
+     */
+    @NotNull
+    Path getConfigurationFile();
+
+    /**
+     * Gets the logger used for this plugin.
+     *
+     * @return logger
+     */
+    @NotNull
+    Logger getLogger();
+}
diff --git a/src/main/java/io/papermc/paper/plugin/configuration/BukkitConfigurationWrapper.java b/src/main/java/io/papermc/paper/plugin/configuration/BukkitConfigurationWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..0a8a020015a143ad3910e18eb107c20073cd7ee1
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/configuration/BukkitConfigurationWrapper.java
@@ -0,0 +1,131 @@
+package io.papermc.paper.plugin.configuration;
+
+import org.bukkit.Bukkit;
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.plugin.PluginLoadOrder;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+
+@ApiStatus.Internal
+public interface BukkitConfigurationWrapper extends PluginConfiguration {
+
+    /**
+     * Gets the bukkit configuration for this plugin configuration.
+     *
+     * @return bukkit configuration
+     */
+    PluginDescriptionFile spigotDescription();
+
+    @Override
+    default @NotNull String getIdentifier() {
+        return this.spigotDescription().getName();
+    }
+
+    @Override
+    default @NotNull String getVersion() {
+        return this.spigotDescription().getVersion();
+    }
+
+    @Override
+    default @NotNull String getMain() {
+        return this.spigotDescription().getMain();
+    }
+
+    @Override
+    default @NotNull String getDisplayName() {
+        return this.spigotDescription().getFullName();
+    }
+
+    @Override
+    default @NotNull String getLoggingPrefix() {
+        String prefix = this.spigotDescription().getPrefix();
+        if (prefix == null) {
+            return this.getIdentifier();
+        }
+
+        return prefix;
+    }
+
+    @Override
+    default @NotNull PluginLoadOrder getLoadPhase() {
+        return this.spigotDescription().getLoad();
+    }
+
+    @Override
+    default @NotNull List<String> getHardDependencies() {
+        return this.spigotDescription().getDepend();
+    }
+
+    @Override
+    default @NotNull List<String> getSoftDependencies() {
+        return this.spigotDescription().getSoftDepend();
+    }
+
+    @Override
+    default @NotNull List<String> getLoadBefore() {
+        return this.spigotDescription().getLoadBefore();
+    }
+
+    @Override
+    default @NotNull List<Permission> getPermissions() {
+        return this.spigotDescription().getPermissions();
+    }
+
+    @Override
+    default @NotNull PermissionDefault getDefaultPermission() {
+        return this.spigotDescription().getPermissionDefault();
+    }
+
+
+    @Override
+    default @NotNull String getApiVersion() {
+        String version = this.spigotDescription().getAPIVersion();
+        if (version == null) {
+            return "<1.13";
+        }
+
+        return version;
+    }
+
+    @Override
+    default @NotNull List<String> getProvides() {
+        return nullable(this.spigotDescription().getProvides());
+    }
+
+    @Override
+    default @Nullable String getWebsite() {
+        return this.spigotDescription().getWebsite();
+    }
+
+    @Override
+    default @Nullable String getDescription() {
+        return this.spigotDescription().getDescription();
+    }
+
+    @Override
+    default @NotNull List<String> getAuthors() {
+        return nullable(this.spigotDescription().getAuthors());
+    }
+
+    @Override
+    default @NotNull List<String> getContributors() {
+        return nullable(this.spigotDescription().getContributors());
+    }
+
+    private static List<String> nullable(List<String> strings) {
+        if (strings == null) {
+            return List.of();
+        }
+
+        return strings;
+    }
+
+    default boolean isLegacy() {
+        return !Bukkit.getUnsafe().isSupportedApiVersion(this.spigotDescription().getAPIVersion());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/configuration/PluginConfiguration.java b/src/main/java/io/papermc/paper/plugin/configuration/PluginConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..3b9f9f3caa5c725739c9937a4cb9d6d8ff9c8a8e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/configuration/PluginConfiguration.java
@@ -0,0 +1,171 @@
+package io.papermc.paper.plugin.configuration;
+
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.bukkit.plugin.PluginLoadOrder;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+
+/**
+ * This class acts as an abstraction for a plugin configuration.
+ */
+public interface PluginConfiguration {
+
+    /**
+     * Gives the name of the plugin. This name is a unique identifier for
+     * plugins.
+     * <ul>
+     * <li>Will only contain alphanumeric characters, underscores, hyphon,
+     *     and period (a-z,A-Z,0-9,_.-).
+     * <li>Typically used for identifying the plugin data folder.
+     * <li>The is the token referenced in {@link #getHardDependencies()}, {@link
+     *     #getSoftDependencies()}, and {@link #getLoadBefore()}.
+     * </ul>
+     * <p>
+     * In the plugin.yml, this entry is named <code>name</code>.
+     * <p>
+     * Example:<blockquote><pre>name: MyPlugin</pre></blockquote>
+     *
+     * @return the name of the plugin
+     */
+    @NotNull
+    String getIdentifier();
+
+    /**
+     * Returns the name of a plugin, including the version.
+     *
+     * @return a descriptive name of the plugin and respective version
+     */
+    @NotNull
+    default String getDisplayName() {
+        return this.getIdentifier() + " v" + this.getVersion();
+    }
+
+    /**
+     * Gives the fully qualified name of the main class for a plugin.
+     * A {@link JavaPlugin} is expected at this location.
+     *
+     * @return the fully qualified main class for the plugin
+     */
+    @NotNull
+    String getMain();
+
+    /**
+     * Gives the phase of server startup that the plugin should be loaded.
+     *
+     * @return phase
+     */
+    @NotNull
+    PluginLoadOrder getLoadPhase();
+
+    /**
+     * Gets the version of this plugin
+     *
+     * @return version string
+     */
+    @NotNull
+    String getVersion();
+
+    /**
+     * Gets the prefix that should be used for the plugin logger.
+     *
+     * @return logger prefix
+     */
+    @NotNull
+    String getLoggingPrefix();
+
+    /**
+     * Gets a list of dependencies that are required for this plugin to load.
+     *
+     * @return immutable list of required dependencies
+     */
+    @NotNull
+    List<String> getHardDependencies();
+
+    /**
+     * Gets a list of dependencies that are used but not required for this plugin to load.
+     *
+     * @return immutable list of soft dependencies
+     */
+    @NotNull
+    List<String> getSoftDependencies();
+
+    /**
+     * Gets a list of dependencies that should be loaded before this plugin is loaded.
+     *
+     * @return immutable list of dependencies to load before
+     */
+    @NotNull
+    List<String> getLoadBefore();
+
+    /**
+     * Gets a list of plugins/dependencies that this plugin provides.
+     *
+     * @return immutable list of provided plugins/dependencies
+     */
+    @NotNull
+    List<String> getProvides();
+
+    /**
+     * Gives a list of authors that created this plugin.
+     *
+     * @return an immutable list of the plugin's authors
+     */
+    @NotNull
+    List<String> getAuthors();
+
+    /**
+     * Gets a list of contributors that created this plugin.
+     *
+     * @return an immutable list of the plugin's contributors
+     */
+    @NotNull
+    List<String> getContributors();
+
+    /**
+     * Gives a human-friendly description of the functionality the plugin
+     * provides.
+     *
+     * @return description or null if unset
+     */
+    @Nullable
+    String getDescription();
+
+    /**
+     * Gets the website for the plugin or the plugin's author.
+     *
+     * @return website or null if unset
+     */
+    @Nullable
+    String getWebsite();
+
+    /**
+     * Gets a list of permissions that are registered in this plugin configuration.
+     *
+     * @return an immutable list of permissions
+     */
+    // TODO: Do we even want this? Why not just use the bootstrapper
+    @NotNull
+    List<Permission> getPermissions();
+
+    /**
+     * Gets the default permission value for configured permissions.
+     *
+     * @return default permission
+     */
+    // TODO: Do we even want this? Why not just use the bootstrapper
+    @NotNull
+    PermissionDefault getDefaultPermission();
+
+    /**
+     * Gets the api version that this plugin supports.
+     *
+     * @return version
+     */
+    @NotNull
+    String getApiVersion();
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/loader/PluginClasspathBuilder.java b/src/main/java/io/papermc/paper/plugin/loader/PluginClasspathBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..4a88737767a811af70fe14fd725c825905e67670
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/loader/PluginClasspathBuilder.java
@@ -0,0 +1,31 @@
+package io.papermc.paper.plugin.loader;
+
+import io.papermc.paper.plugin.loader.library.ClassPathLibrary;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Class used for building classpath configurations in plugin loading.
+ */
+public interface PluginClasspathBuilder {
+
+    /**
+     * Adds a new classpath library to this classpath builder.
+     * <blockquote><pre>{@code
+     * public void classloader(PluginClasspathBuilder classpathBuilder) {
+     *     classpathBuilder.addLibrary(new JarLibrary(Path.of("bob.jar")));
+     *
+     *     MavenLibraryResolver resolver = new MavenLibraryResolver();
+     *     resolver.addDependency(new Dependency(new DefaultArtifact("namespace:identifier:version"), null));
+     *     resolver.addRepository(new RemoteRepository.Builder("my_repo", "default", "https://repo.mymavenrepo.com/repository/maven-public/").build());
+     *
+     *     classpathBuilder.addLibrary(resolver);
+     * }
+     *
+     * }</pre></blockquote>
+     *
+     * @param classPathLibrary library
+     * @return self
+     */
+    @NotNull
+    PluginClasspathBuilder addLibrary(@NotNull ClassPathLibrary classPathLibrary);
+}
diff --git a/src/main/java/io/papermc/paper/plugin/loader/PluginLoader.java b/src/main/java/io/papermc/paper/plugin/loader/PluginLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..984301dd39faaaf6b64ceef118db4b21caf83048
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/loader/PluginLoader.java
@@ -0,0 +1,25 @@
+package io.papermc.paper.plugin.loader;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A plugin loader is responsible for creating certain aspects of a plugin before it is created.
+ * <p>
+ * The goal of this is to allow certain configuration values to be moved and can instead be
+ * configured at run time inorder to make plugins a bit more dynamic.
+ * <p>
+ * It should be noted that this class will be called from a different classloader, this will cause any static values
+ * set in this class/any other classes loaded not to persist when the plugin loads.
+ */
+public interface PluginLoader {
+
+    /**
+     * Called by the server, allows you to configure the classpath that your plugin is run on.
+     * This allows you to configure dependencies for your plugin where jars can be downloaded or
+     * provided during runtime.
+     *
+     * @param classpathBuilder classpath builder
+     */
+    void classloader(@NotNull PluginClasspathBuilder classpathBuilder);
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/loader/library/ClassPathLibrary.java b/src/main/java/io/papermc/paper/plugin/loader/library/ClassPathLibrary.java
new file mode 100644
index 0000000000000000000000000000000000000000..ce932d748670521cc28a99cdf717d14ab34ddbcb
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/loader/library/ClassPathLibrary.java
@@ -0,0 +1,17 @@
+package io.papermc.paper.plugin.loader.library;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Responsible for loading libraries into the LibraryStore.
+ */
+public interface ClassPathLibrary {
+
+    /**
+     * Loads the correct jars into the librarystore.
+     *
+     * @param store library store
+     * @throws LibraryLoadingException if library loading failed for this classpath library
+     */
+    void addToLibraryStore(@NotNull LibraryStore store) throws LibraryLoadingException;
+}
diff --git a/src/main/java/io/papermc/paper/plugin/loader/library/LibraryLoadingException.java b/src/main/java/io/papermc/paper/plugin/loader/library/LibraryLoadingException.java
new file mode 100644
index 0000000000000000000000000000000000000000..79ba423a364b50588f3ee87fdc69155cb8e64ad0
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/loader/library/LibraryLoadingException.java
@@ -0,0 +1,15 @@
+package io.papermc.paper.plugin.loader.library;
+
+/**
+ * Indicates that an exception has occured while loading a library.
+ */
+public class LibraryLoadingException extends RuntimeException {
+
+    public LibraryLoadingException(String s) {
+        super(s);
+    }
+
+    public LibraryLoadingException(String s, Exception e) {
+        super(s, e);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/loader/library/LibraryStore.java b/src/main/java/io/papermc/paper/plugin/loader/library/LibraryStore.java
new file mode 100644
index 0000000000000000000000000000000000000000..60d336b9524d5250498e1aa7ea902d5854cee3c8
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/loader/library/LibraryStore.java
@@ -0,0 +1,14 @@
+package io.papermc.paper.plugin.loader.library;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.nio.file.Path;
+
+/**
+ * Represents a storage that stores library jars.
+ */
+public interface LibraryStore {
+
+    void addLibrary(@NotNull Path library);
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/loader/library/impl/JarLibrary.java b/src/main/java/io/papermc/paper/plugin/loader/library/impl/JarLibrary.java
new file mode 100644
index 0000000000000000000000000000000000000000..dac76de2cfc5f537b2c237780a3bed0d56a0cf03
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/loader/library/impl/JarLibrary.java
@@ -0,0 +1,34 @@
+package io.papermc.paper.plugin.loader.library.impl;
+
+import io.papermc.paper.plugin.loader.library.ClassPathLibrary;
+import io.papermc.paper.plugin.loader.library.LibraryLoadingException;
+import io.papermc.paper.plugin.loader.library.LibraryStore;
+import org.jetbrains.annotations.NotNull;
+
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+/**
+ * A simple jar library, will error if the jar is not found.
+ */
+public class JarLibrary implements ClassPathLibrary {
+
+    private final Path path;
+
+    /**
+     * Creates a jar library with the given path.
+     *
+     * @param path given path
+     */
+    public JarLibrary(@NotNull Path path) {
+        this.path = path;
+    }
+
+    @Override
+    public void addToLibraryStore(@NotNull LibraryStore store) throws LibraryLoadingException {
+        if (Files.notExists(this.path)) {
+            throw new LibraryLoadingException("Could not find library at " + this.path);
+        }
+        store.addLibrary(this.path);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/loader/library/impl/maven/MavenLibraryResolver.java b/src/main/java/io/papermc/paper/plugin/loader/library/impl/maven/MavenLibraryResolver.java
new file mode 100644
index 0000000000000000000000000000000000000000..382c5472ed5702e8ee787a84a74cd33e336b0a11
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/loader/library/impl/maven/MavenLibraryResolver.java
@@ -0,0 +1,119 @@
+package io.papermc.paper.plugin.loader.library.impl.maven;
+
+import io.papermc.paper.plugin.loader.library.ClassPathLibrary;
+import io.papermc.paper.plugin.loader.library.LibraryLoadingException;
+import io.papermc.paper.plugin.loader.library.LibraryStore;
+import org.apache.maven.repository.internal.MavenRepositorySystemUtils;
+import org.eclipse.aether.DefaultRepositorySystemSession;
+import org.eclipse.aether.RepositorySystem;
+import org.eclipse.aether.collection.CollectRequest;
+import org.eclipse.aether.connector.basic.BasicRepositoryConnectorFactory;
+import org.eclipse.aether.graph.Dependency;
+import org.eclipse.aether.graph.DependencyFilter;
+import org.eclipse.aether.impl.DefaultServiceLocator;
+import org.eclipse.aether.repository.LocalRepository;
+import org.eclipse.aether.repository.RemoteRepository;
+import org.eclipse.aether.repository.RepositoryPolicy;
+import org.eclipse.aether.resolution.ArtifactResult;
+import org.eclipse.aether.resolution.DependencyRequest;
+import org.eclipse.aether.resolution.DependencyResolutionException;
+import org.eclipse.aether.resolution.DependencyResult;
+import org.eclipse.aether.spi.connector.RepositoryConnectorFactory;
+import org.eclipse.aether.spi.connector.transport.TransporterFactory;
+import org.eclipse.aether.transfer.AbstractTransferListener;
+import org.eclipse.aether.transfer.TransferCancelledException;
+import org.eclipse.aether.transfer.TransferEvent;
+import org.eclipse.aether.transport.http.HttpTransporterFactory;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * A maven library, this allows you to resolve jars from maven repositories.
+ * This class will automatically cache resolved libraries when needed into the libraries directory.
+ */
+public class MavenLibraryResolver implements ClassPathLibrary {
+
+    private static final Logger logger = Logger.getLogger("MavenLibraryResolver");
+
+    private final RepositorySystem repository;
+    private final DefaultRepositorySystemSession session;
+    private final List<RemoteRepository> repositories = new ArrayList<>();
+    private final List<Dependency> dependencies = new ArrayList<>();
+
+    private DependencyFilter filter = null;
+
+    public MavenLibraryResolver() {
+        DefaultServiceLocator locator = MavenRepositorySystemUtils.newServiceLocator();
+        locator.addService(RepositoryConnectorFactory.class, BasicRepositoryConnectorFactory.class);
+        locator.addService(TransporterFactory.class, HttpTransporterFactory.class);
+
+        this.repository = locator.getService(RepositorySystem.class);
+        this.session = MavenRepositorySystemUtils.newSession();
+
+        this.session.setChecksumPolicy(RepositoryPolicy.CHECKSUM_POLICY_FAIL);
+        this.session.setLocalRepositoryManager(this.repository.newLocalRepositoryManager(this.session, new LocalRepository("libraries")));
+        this.session.setTransferListener(new AbstractTransferListener() {
+            @Override
+            public void transferInitiated(@NotNull TransferEvent event) throws TransferCancelledException {
+                logger.log(Level.INFO, "Downloading {0}", event.getResource().getRepositoryUrl() + event.getResource().getResourceName());
+            }
+        });
+        this.session.setReadOnly();
+    }
+
+
+    /**
+     * Adds the provided dependency to the library resolver.
+     * The dependency from the first valid repository will be chosen.
+     *
+     * @param dependency provided dependency
+     * @see MavenLibraryResolver#addRepository(RemoteRepository)
+     */
+    public void addDependency(@NotNull Dependency dependency) {
+        this.dependencies.add(dependency);
+    }
+
+    /**
+     * Adds the provided repository to the library resolver.
+     * The order in which these are added does matter, as dependency resolving will start at the first added
+     * repository.
+     *
+     * @param remoteRepository provided repository
+     */
+    public void addRepository(@NotNull RemoteRepository remoteRepository) {
+        this.repositories.add(remoteRepository);
+    }
+
+    // Do we want this? We would need to do multiple resolveDependencies calls if we want a filter per repository.
+//    public void setFilter(DependencyFilter filter) {
+//        this.filter = filter;
+//    }
+
+    /**
+     * Resolves the provided dependencies and adds them to the library store.
+     *
+     * @param store library store
+     * @throws LibraryLoadingException if resolving a dependency failed
+     */
+    @Override
+    public void addToLibraryStore(@NotNull LibraryStore store) throws LibraryLoadingException {
+        List<RemoteRepository> repos = this.repository.newResolutionRepositories(this.session, this.repositories);
+
+        DependencyResult result;
+        try {
+            result = this.repository.resolveDependencies(this.session, new DependencyRequest(new CollectRequest((Dependency) null, this.dependencies, repos), this.filter));
+        } catch (DependencyResolutionException ex) {
+            throw new LibraryLoadingException("Error resolving libraries", ex);
+        }
+
+        for (ArtifactResult artifact : result.getArtifactResults()) {
+            File file = artifact.getArtifact().getFile();
+            store.addLibrary(file.toPath());
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/classloader/ConfiguredPluginClassLoader.java b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/ConfiguredPluginClassLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..90171c7be6fa05ce69398f593265368a5a9efef6
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/ConfiguredPluginClassLoader.java
@@ -0,0 +1,18 @@
+package io.papermc.paper.plugin.provider.service.classloader;
+
+import io.papermc.paper.plugin.configuration.PluginConfiguration;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.Closeable;
+
+@ApiStatus.Internal
+public interface ConfiguredPluginClassLoader extends Closeable {
+    PluginConfiguration getConfiguration();
+
+    Class<?> loadClass(@NotNull String name, boolean resolve, boolean checkGlobal, boolean checkLibraries) throws ClassNotFoundException;
+
+    // Called in the constructor, at the very top
+    void init(JavaPlugin plugin);
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PaperPluginClassLoaderStorage.java b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PaperPluginClassLoaderStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..82d387b55a25e5418c763b97b77f5bec93f86e41
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PaperPluginClassLoaderStorage.java
@@ -0,0 +1,81 @@
+package io.papermc.paper.plugin.provider.service.classloader;
+
+import io.papermc.paper.plugin.configuration.PluginConfiguration;
+import org.bukkit.Bukkit;
+import org.bukkit.plugin.PluginManager;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+/**
+ * This is used for connecting multiple classloaders.
+ */
+@ApiStatus.Internal
+public final class PaperPluginClassLoaderStorage {
+
+    private static final boolean DISABLE_CLASS_PRIORITIZATION = Boolean.getBoolean("Paper.DisableClassPrioritization");
+
+    private final Map<String, ReentrantReadWriteLock> classLoadLock = new HashMap<>();
+    private final Map<String, Integer> classLoadLockCount = new HashMap<>();
+    public final List<ConfiguredPluginClassLoader> classLoaders = new CopyOnWriteArrayList<>();
+
+    public static final PaperPluginClassLoaderStorage INSTANCE = new PaperPluginClassLoaderStorage();
+
+    public PaperPluginClassLoaderStorage() {
+    }
+
+    public Class<?> getClassByName(String name, boolean resolve, PluginConfiguration pluginConfiguration, @Nullable ConfiguredPluginClassLoader requester) {
+        // make MT safe
+        java.util.concurrent.locks.ReentrantReadWriteLock lock;
+        synchronized (this.classLoadLock) {
+            lock = this.classLoadLock.computeIfAbsent(name, (x) -> new java.util.concurrent.locks.ReentrantReadWriteLock());
+            this.classLoadLockCount.compute(name, (x, prev) -> prev != null ? prev + 1 : 1);
+        }
+        lock.writeLock().lock();
+
+        try {
+            PluginManager manager = Bukkit.getPluginManager();
+            if (!DISABLE_CLASS_PRIORITIZATION && requester != null) {
+                try {
+                    return requester.loadClass(name, false, false, manager.isTransitiveDependency(pluginConfiguration, requester.getConfiguration()));
+                } catch (ClassNotFoundException cnfe) {
+                }
+            }
+            for (ConfiguredPluginClassLoader loader : this.classLoaders) {
+                try {
+                    return loader.loadClass(name, resolve, false, manager.isTransitiveDependency(pluginConfiguration, loader.getConfiguration()));
+                } catch (ClassNotFoundException cnfe) {
+                }
+            }
+        } finally {
+            synchronized (this.classLoadLock) {
+                lock.writeLock().unlock();
+                if (this.classLoadLockCount.get(name) == 1) {
+                    this.classLoadLock.remove(name);
+                    this.classLoadLockCount.remove(name);
+                } else {
+                    this.classLoadLockCount.compute(name, (x, prev) -> prev - 1);
+                }
+            }
+        }
+        return null;
+    }
+
+
+    public void add(ConfiguredPluginClassLoader classLoader) {
+        this.classLoaders.add(classLoader);
+    }
+
+    public void remove(ConfiguredPluginClassLoader loader) {
+        this.classLoaders.remove(loader);
+    }
+
+    public boolean contains(ConfiguredPluginClassLoader pluginLoader) {
+        return this.classLoaders.contains(pluginLoader);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/classloader/bytecode/ClassloaderBytecodeModifier.java b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/bytecode/ClassloaderBytecodeModifier.java
new file mode 100644
index 0000000000000000000000000000000000000000..d332f21f3dd7426f26ee00c6e0247864e430e299
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/bytecode/ClassloaderBytecodeModifier.java
@@ -0,0 +1,26 @@
+package io.papermc.paper.plugin.provider.service.classloader.bytecode;
+
+import io.papermc.paper.plugin.configuration.PluginConfiguration;
+import org.jetbrains.annotations.ApiStatus;
+
+@ApiStatus.Internal
+public abstract class ClassloaderBytecodeModifier {
+
+    public static ClassloaderBytecodeModifier INSTANCE;
+
+    public static void setInstance(ClassloaderBytecodeModifier instance) {
+        if (INSTANCE != null)  {
+            throw new IllegalStateException();
+        }
+
+        INSTANCE = instance;
+    }
+
+    public static ClassloaderBytecodeModifier getInstance() {
+        return INSTANCE;
+    }
+
+
+    public abstract byte[] modify(PluginConfiguration config, byte[] bytecode);
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/util/NamespaceChecker.java b/src/main/java/io/papermc/paper/plugin/provider/util/NamespaceChecker.java
new file mode 100644
index 0000000000000000000000000000000000000000..4efcd3eb41b8a93f8c2d606f2993ef1c7a8e677c
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/util/NamespaceChecker.java
@@ -0,0 +1,37 @@
+package io.papermc.paper.plugin.provider.util;
+
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+@ApiStatus.Internal
+public class NamespaceChecker {
+
+    private static final String[] QUICK_INVALID_NAMESPACES = {
+        "net.minecraft.",
+        "org.bukkit.",
+        "io.papermc.paper.",
+        "com.destroystokoyo.paper."
+    };
+
+    /**
+     * Used for a variety of namespaces that shouldn't be resolved and should instead be moved to
+     * other classloaders. We can assume this because only plugins should be using this classloader.
+     *
+     * @param name namespace
+     */
+    public static void validateNameSpaceForClassloading(@NotNull String name) throws ClassNotFoundException {
+        if (!isValidNameSpace(name)) {
+            throw new ClassNotFoundException(name);
+        }
+    }
+
+    public static boolean isValidNameSpace(@NotNull String name) {
+        for (String string : QUICK_INVALID_NAMESPACES) {
+            if (name.startsWith(string)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/util/ProviderUtil.java b/src/main/java/io/papermc/paper/plugin/provider/util/ProviderUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..06fb087e8ee7f28b638a9f8819d3a0d272a65a9c
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/util/ProviderUtil.java
@@ -0,0 +1,48 @@
+package io.papermc.paper.plugin.provider.util;
+
+import com.destroystokyo.paper.util.SneakyThrow;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.function.Consumer;
+
+@ApiStatus.Internal
+public class ProviderUtil {
+
+    public static <T> T loadClass(@NotNull String clazz, @NotNull Class<T> classType, @NotNull ClassLoader loader) {
+        return loadClass(clazz, classType, loader, null);
+    }
+
+    public static <T> T loadClass(@NotNull String clazz, @NotNull Class<T> classType, @NotNull ClassLoader loader, @NotNull Runnable onError) {
+        try {
+            T clazzInstance;
+
+            try {
+                Class<?> jarClass = Class.forName(clazz, true, loader);
+
+                Class<? extends T> pluginClass;
+                try {
+                    pluginClass = jarClass.asSubclass(classType);
+                } catch (ClassCastException ex) {
+                    throw new ClassCastException("class '%s' does not extend '%s'".formatted(clazz, classType));
+                }
+
+                clazzInstance = pluginClass.getDeclaredConstructor().newInstance();
+            } catch (IllegalAccessException exception) {
+                throw new RuntimeException("No public constructor");
+            } catch (InstantiationException exception) {
+                throw new RuntimeException("Abnormal plugin type", exception);
+            }
+
+            return clazzInstance;
+        } catch (Throwable e) {
+            if (onError != null) {
+                onError.run();
+            }
+            SneakyThrow.sneaky(e);
+        }
+
+        throw new AssertionError(); // Shouldn't happen
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/registry/RegistryAccess.java b/src/main/java/io/papermc/paper/registry/RegistryAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..ce66c664003e80087df88bded37ef17bd398bf85
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/RegistryAccess.java
@@ -0,0 +1,16 @@
+package io.papermc.paper.registry;
+
+import org.jetbrains.annotations.NotNull;
+
+public class RegistryAccess {
+
+    /**
+     * Stub
+     *
+     * @return
+     */
+    @NotNull
+    public static RegistryAccess getInstance() {
+        return new RegistryAccess();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/PluginCommand.java b/src/main/java/org/bukkit/command/PluginCommand.java
index 1dbbc244309043b18c1d71707c4fb066c0d0e02d..08d3ff24d5318b0c77d6467bcb705bffac202842 100644
--- a/src/main/java/org/bukkit/command/PluginCommand.java
+++ b/src/main/java/org/bukkit/command/PluginCommand.java
@@ -14,7 +14,7 @@ public final class PluginCommand extends Command implements PluginIdentifiableCo
     private CommandExecutor executor;
     private TabCompleter completer;

-    protected PluginCommand(@NotNull String name, @NotNull Plugin owner) {
+    public PluginCommand(@NotNull String name, @NotNull Plugin owner) { // Paper
         super(name);
         this.executor = owner;
         this.owningPlugin = owner;
diff --git a/src/main/java/org/bukkit/command/SimpleCommandMap.java b/src/main/java/org/bukkit/command/SimpleCommandMap.java
index b8623575b1c1b565560c2dd6438190716845a652..785952d60df7c0ab7b247ba81d1970b5a90e5340 100644
--- a/src/main/java/org/bukkit/command/SimpleCommandMap.java
+++ b/src/main/java/org/bukkit/command/SimpleCommandMap.java
@@ -33,7 +33,7 @@ public class SimpleCommandMap implements CommandMap {
     private void setDefaultCommands() {
         register("bukkit", new VersionCommand("version"));
         register("bukkit", new ReloadCommand("reload"));
-        register("bukkit", new PluginsCommand("plugins"));
+        //register("bukkit", new PluginsCommand("plugins")); Paper
         register("bukkit", new co.aikar.timings.TimingsCommand("timings")); // Paper
     }

diff --git a/src/main/java/org/bukkit/plugin/Plugin.java b/src/main/java/org/bukkit/plugin/Plugin.java
index 08aef59d8443038771704d9587e31f299e587307..ef3d1b9cf93903d50f11d3504ee5a6526cc6cc08 100644
--- a/src/main/java/org/bukkit/plugin/Plugin.java
+++ b/src/main/java/org/bukkit/plugin/Plugin.java
@@ -3,6 +3,8 @@ package org.bukkit.plugin;
 import java.io.File;
 import java.io.InputStream;
 import java.util.logging.Logger;
+
+import io.papermc.paper.plugin.configuration.PluginConfiguration;
 import org.bukkit.Server;
 import org.bukkit.command.TabExecutor;
 import org.bukkit.configuration.file.FileConfiguration;
@@ -30,10 +32,20 @@ public interface Plugin extends TabExecutor {
      * Returns the plugin.yaml file containing the details for this plugin
      *
      * @return Contents of the plugin.yaml file
+     * @deprecated May be inaccurate due to different plugin implementations.
+     * @see Plugin#getConfiguration()
      */
+    @Deprecated // Paper
     @NotNull
     public PluginDescriptionFile getDescription();

+    /**
+     * Gets the plugin configuration for this plugin.
+     * @return configuration
+     */
+    @NotNull
+    PluginConfiguration getConfiguration();
+
     /**
      * Gets a {@link FileConfiguration} for this plugin, read through
      * "config.yml"
@@ -92,8 +104,10 @@ public interface Plugin extends TabExecutor {
     /**
      * Gets the associated PluginLoader responsible for this plugin
      *
+     * @deprecated
      * @return PluginLoader that controls this plugin
      */
+    @Deprecated(forRemoval = true)
     @NotNull
     public PluginLoader getPluginLoader();

diff --git a/src/main/java/org/bukkit/plugin/PluginBase.java b/src/main/java/org/bukkit/plugin/PluginBase.java
index 94f8ceb965cecb5669a84a0ec61c0f706c2a2673..e670c89feafcdbc003a3a615e2003d7cea4a014d 100644
--- a/src/main/java/org/bukkit/plugin/PluginBase.java
+++ b/src/main/java/org/bukkit/plugin/PluginBase.java
@@ -31,6 +31,6 @@ public abstract class PluginBase implements Plugin {
     @Override
     @NotNull
     public final String getName() {
-        return getDescription().getName();
+        return getConfiguration().getIdentifier(); // Paper
     }
 }
diff --git a/src/main/java/org/bukkit/plugin/PluginDescriptionFile.java b/src/main/java/org/bukkit/plugin/PluginDescriptionFile.java
index 0c9f4d1e9104fa6951114c1f9ec954dfcc749196..f4439d634e5c63b0dad715c87c255e11548c5538 100644
--- a/src/main/java/org/bukkit/plugin/PluginDescriptionFile.java
+++ b/src/main/java/org/bukkit/plugin/PluginDescriptionFile.java
@@ -194,7 +194,7 @@ import org.yaml.snakeyaml.nodes.Tag;
  *      inferno.burningdeaths: true
  *</pre></blockquote>
  */
-public final class PluginDescriptionFile {
+public class PluginDescriptionFile implements io.papermc.paper.plugin.configuration.BukkitConfigurationWrapper { // Paper
     private static final Pattern VALID_NAME = Pattern.compile("^[A-Za-z0-9 _.-]+$");
     private static final ThreadLocal<Yaml> YAML = new ThreadLocal<Yaml>() {
         @Override
@@ -254,6 +254,35 @@ public final class PluginDescriptionFile {
     private Set<PluginAwareness> awareness = ImmutableSet.of();
     private String apiVersion = null;
     private List<String> libraries = ImmutableList.of();
+    // Paper start - oh my goddddd
+    /**
+     * Don't use this.
+     */
+    @org.jetbrains.annotations.ApiStatus.Internal
+    public PluginDescriptionFile(String rawName, String name, List<String> provides, String main, String classLoaderOf, List<String> depend, List<String> softDepend, List<String> loadBefore, String version, Map<String, Map<String, Object>> commands, String description, List<String> authors, List<String> contributors, String website, String prefix, PluginLoadOrder order, List<Permission> permissions, PermissionDefault defaultPerm, Set<PluginAwareness> awareness, String apiVersion, List<String> libraries) {
+        this.rawName = rawName;
+        this.name = name;
+        this.provides = provides;
+        this.main = main;
+        this.classLoaderOf = classLoaderOf;
+        this.depend = depend;
+        this.softDepend = softDepend;
+        this.loadBefore = loadBefore;
+        this.version = version;
+        this.commands = commands;
+        this.description = description;
+        this.authors = authors;
+        this.contributors = contributors;
+        this.website = website;
+        this.prefix = prefix;
+        this.order = order;
+        this.permissions = permissions;
+        this.defaultPerm = defaultPerm;
+        this.awareness = awareness;
+        this.apiVersion = apiVersion;
+        this.libraries = libraries;
+    }
+    // Paper end

     public PluginDescriptionFile(@NotNull final InputStream stream) throws InvalidDescriptionException {
         loadMap(asMap(YAML.get().load(stream)));
@@ -365,8 +394,7 @@ public final class PluginDescriptionFile {
      *
      * @return the version of the plugin
      */
-    @NotNull
-    public String getVersion() {
+    public @NotNull String getVersion() {
         return version;
     }

@@ -392,8 +420,7 @@ public final class PluginDescriptionFile {
      *
      * @return the fully qualified main class for the plugin
      */
-    @NotNull
-    public String getMain() {
+    public @NotNull String getMain() {
         return main;
     }

@@ -412,8 +439,7 @@ public final class PluginDescriptionFile {
      *
      * @return description of this plugin, or null if not specified
      */
-    @Nullable
-    public String getDescription() {
+    public @NotNull String getDescription() {
         return description;
     }

@@ -1270,4 +1296,11 @@ public final class PluginDescriptionFile {
     public String getRawName() {
         return rawName;
     }
+    // Paper
+    @NotNull
+    @Override
+    public PluginDescriptionFile spigotDescription() {
+        return this;
+    }
+    // Paper end
 }
diff --git a/src/main/java/org/bukkit/plugin/PluginLoader.java b/src/main/java/org/bukkit/plugin/PluginLoader.java
index 256e440e699942e3c9da4205bb964bdc10ec92c4..7ab52fa29dcd6ef963f82471999e0e7c25d9b107 100644
--- a/src/main/java/org/bukkit/plugin/PluginLoader.java
+++ b/src/main/java/org/bukkit/plugin/PluginLoader.java
@@ -11,7 +11,11 @@ import org.jetbrains.annotations.NotNull;
 /**
  * Represents a plugin loader, which handles direct access to specific types
  * of plugins
+ * @deprecated Plugin loading now occurs at a point which makes it impossible to expose this
+ * behavior. All methods will return UOExceptions.
+ * Generally, this whole system has not aged well and the plans of this system has been shifted.
  */
+@Deprecated(forRemoval = true) // Paper
 public interface PluginLoader {

     /**
@@ -36,8 +40,10 @@ public interface PluginLoader {
      *     specified file
      * @throws InvalidDescriptionException If the plugin description file
      *     could not be created
+     * @deprecated No longer applicable to all plugin types
      */
     @NotNull
+    @Deprecated // Paper
     public PluginDescriptionFile getPluginDescription(@NotNull File file) throws InvalidDescriptionException;

     /**
diff --git a/src/main/java/org/bukkit/plugin/PluginManager.java b/src/main/java/org/bukkit/plugin/PluginManager.java
index 0d1b20f2b5580ea5505ccc2f003925dbcee67199..97d498cf3c3545e2835fe0d4c5e4fe9f121014b3 100644
--- a/src/main/java/org/bukkit/plugin/PluginManager.java
+++ b/src/main/java/org/bukkit/plugin/PluginManager.java
@@ -2,6 +2,8 @@ package org.bukkit.plugin;

 import java.io.File;
 import java.util.Set;
+
+import io.papermc.paper.plugin.configuration.PluginConfiguration;
 import org.bukkit.event.Event;
 import org.bukkit.event.EventPriority;
 import org.bukkit.event.Listener;
@@ -14,7 +16,7 @@ import org.jetbrains.annotations.Nullable;
 /**
  * Handles all plugin management from the Server
  */
-public interface PluginManager {
+public interface PluginManager extends io.papermc.paper.plugin.PermissionManager { // Paper

     /**
      * Registers the specified plugin loader
@@ -22,7 +24,9 @@ public interface PluginManager {
      * @param loader Class name of the PluginLoader to register
      * @throws IllegalArgumentException Thrown when the given Class is not a
      *     valid PluginLoader
+     * @deprecated Adding custom loaders is no longer supported, only .jars will be loaded.
      */
+    @Deprecated(forRemoval = true) // Paper
     public void registerInterface(@NotNull Class<? extends PluginLoader> loader) throws IllegalArgumentException;

     /**
@@ -319,4 +323,16 @@ public interface PluginManager {
      * @return True if event timings are to be used
      */
     public boolean useTimings();
+
+    // Paper start
+    @org.jetbrains.annotations.ApiStatus.Internal
+    boolean isTransitiveDependency(PluginConfiguration pluginConfiguration, PluginConfiguration dependencyConfig);
+
+    /**
+     * Sets the permission manager to be used for this server.
+     *
+     * @param permissionManager permission manager
+     */
+    void overridePermissionManager(@Nullable Plugin plugin, @Nullable io.papermc.paper.plugin.PermissionManager permissionManager);
+    // Paper end
 }
diff --git a/src/main/java/org/bukkit/plugin/SimplePluginManager.java b/src/main/java/org/bukkit/plugin/SimplePluginManager.java
index ed07f5820281b139739f673fa4e25171de81b894..1462d55789486f22ea1eaa9a41063f11f9c86516 100644
--- a/src/main/java/org/bukkit/plugin/SimplePluginManager.java
+++ b/src/main/java/org/bukkit/plugin/SimplePluginManager.java
@@ -41,7 +41,11 @@ import org.jetbrains.annotations.Nullable;

 /**
  * Handles all plugin management from the Server
+ * @deprecated No longer the used implementation. Please move away from injecting into this class!
+ * Injecting into this class will not work in the future.
  */
+@org.jetbrains.annotations.ApiStatus.ScheduledForRemoval(inVersion = "1.20") // Paper - idk. when?
+@Deprecated(forRemoval = true) // Paper
 public final class SimplePluginManager implements PluginManager {
     private final Server server;
     private final Map<Pattern, PluginLoader> fileAssociations = new HashMap<Pattern, PluginLoader>();
@@ -50,10 +54,13 @@ public final class SimplePluginManager implements PluginManager {
     private MutableGraph<String> dependencyGraph = GraphBuilder.directed().build();
     private File updateDirectory;
     private final SimpleCommandMap commandMap;
-    private final Map<String, Permission> permissions = new HashMap<String, Permission>();
-    private final Map<Boolean, Set<Permission>> defaultPerms = new LinkedHashMap<Boolean, Set<Permission>>();
-    private final Map<String, Map<Permissible, Boolean>> permSubs = new HashMap<String, Map<Permissible, Boolean>>();
-    private final Map<Boolean, Map<Permissible, Boolean>> defSubs = new HashMap<Boolean, Map<Permissible, Boolean>>();
+    // Paper start
+    public final Map<String, Permission> permissions = new HashMap<String, Permission>();
+    public final Map<Boolean, Set<Permission>> defaultPerms = new LinkedHashMap<Boolean, Set<Permission>>();
+    public final Map<String, Map<Permissible, Boolean>> permSubs = new HashMap<String, Map<Permissible, Boolean>>();
+    public final Map<Boolean, Map<Permissible, Boolean>> defSubs = new HashMap<Boolean, Map<Permissible, Boolean>>();
+    public PluginManager paperPluginManager;
+    // Paper end
     private boolean useTimings = false;

     public SimplePluginManager(@NotNull Server instance, @NotNull SimpleCommandMap commandMap) {
@@ -115,6 +122,18 @@ public final class SimplePluginManager implements PluginManager {
     }
     @NotNull
     public Plugin[] loadPlugins(final @NotNull File directory, final @NotNull List<File> extraPluginJars) {
+        if (true) {
+            List<Plugin> pluginList = new ArrayList<>();
+            java.util.Collections.addAll(pluginList, this.paperPluginManager.loadPlugins(directory));
+            for (File file : extraPluginJars) {
+                try {
+                    pluginList.add(this.paperPluginManager.loadPlugin(file));
+                } catch (Exception e) {
+                    this.server.getLogger().log(Level.SEVERE, "Plugin loading error!", e);
+                }
+            }
+            return pluginList.toArray(new Plugin[0]);
+        }
         // Paper end
         Preconditions.checkArgument(directory != null, "Directory cannot be null");
         Preconditions.checkArgument(directory.isDirectory(), "Directory must be a directory");
@@ -393,6 +412,13 @@ public final class SimplePluginManager implements PluginManager {
     @Override
     @Nullable
     public synchronized Plugin loadPlugin(@NotNull File file) throws InvalidPluginException, UnknownDependencyException {
+        if (true) {
+            try {
+                return this.paperPluginManager.loadPlugin(file);
+            } catch (org.bukkit.plugin.InvalidDescriptionException ignored) {
+                return null;
+            }
+        }
         Preconditions.checkArgument(file != null, "File cannot be null");

         file = checkUpdate(file); // Paper - update the reference in case checkUpdate renamed it
@@ -484,12 +510,14 @@ public final class SimplePluginManager implements PluginManager {
     @Override
     @Nullable
     public synchronized Plugin getPlugin(@NotNull String name) {
+        if (true) {return this.paperPluginManager.getPlugin(name);} // Paper
         return lookupNames.get(name.replace(' ', '_').toLowerCase(java.util.Locale.ENGLISH)); // Paper
     }

     @Override
     @NotNull
     public synchronized Plugin[] getPlugins() {
+        if (true) {return this.paperPluginManager.getPlugins();} // Paper
         return plugins.toArray(new Plugin[plugins.size()]);
     }

@@ -503,6 +531,7 @@ public final class SimplePluginManager implements PluginManager {
      */
     @Override
     public boolean isPluginEnabled(@NotNull String name) {
+        if (true) {return this.paperPluginManager.isPluginEnabled(name);} // Paper
         Plugin plugin = getPlugin(name);

         return isPluginEnabled(plugin);
@@ -516,6 +545,7 @@ public final class SimplePluginManager implements PluginManager {
      */
     @Override
     public synchronized boolean isPluginEnabled(@Nullable Plugin plugin) { // Paper - synchronize
+        if (true) {return this.paperPluginManager.isPluginEnabled(plugin);} // Paper
         if ((plugin != null) && (plugins.contains(plugin))) {
             return plugin.isEnabled();
         } else {
@@ -525,6 +555,7 @@ public final class SimplePluginManager implements PluginManager {

     @Override
     public synchronized void enablePlugin(@NotNull final Plugin plugin) { // Paper - synchronize
+        if (true) {this.paperPluginManager.enablePlugin(plugin); return;} // Paper
         if (!plugin.isEnabled()) {
             List<Command> pluginCommands = PluginCommandYamlParser.parse(plugin);

@@ -545,6 +576,7 @@ public final class SimplePluginManager implements PluginManager {

     @Override
     public void disablePlugins() {
+        if (true) {this.paperPluginManager.disablePlugins(); return;} // Paper
         Plugin[] plugins = getPlugins();
         for (int i = plugins.length - 1; i >= 0; i--) {
             disablePlugin(plugins[i]);
@@ -568,6 +600,7 @@ public final class SimplePluginManager implements PluginManager {

     @Override
     public synchronized void disablePlugin(@NotNull final Plugin plugin) { // Paper - synchronize
+        if (true) {this.paperPluginManager.disablePlugin(plugin); return;} // Paper
         if (plugin.isEnabled()) {
             try {
                 plugin.getPluginLoader().disablePlugin(plugin);
@@ -624,6 +657,7 @@ public final class SimplePluginManager implements PluginManager {

     @Override
     public void clearPlugins() {
+        if (true) {this.paperPluginManager.clearPlugins(); return;} // Paper
         synchronized (this) {
             disablePlugins();
             plugins.clear();
@@ -645,6 +679,7 @@ public final class SimplePluginManager implements PluginManager {
      */
     @Override
     public void callEvent(@NotNull Event event) {
+        if (true) {this.paperPluginManager.callEvent(event); return;} // Paper
         // Paper - replace callEvent by merging to below method
         if (event.isAsynchronous() && server.isPrimaryThread()) {
             throw new IllegalStateException(event.getEventName() + " may only be triggered asynchronously.");
@@ -689,6 +724,7 @@ public final class SimplePluginManager implements PluginManager {

     @Override
     public void registerEvents(@NotNull Listener listener, @NotNull Plugin plugin) {
+        if (true) {this.paperPluginManager.registerEvents(listener, plugin); return;} // Paper
         if (!plugin.isEnabled()) {
             throw new IllegalPluginAccessException("Plugin attempted to register " + listener + " while not enabled");
         }
@@ -701,6 +737,7 @@ public final class SimplePluginManager implements PluginManager {

     @Override
     public void registerEvent(@NotNull Class<? extends Event> event, @NotNull Listener listener, @NotNull EventPriority priority, @NotNull EventExecutor executor, @NotNull Plugin plugin) {
+        if (true) {this.paperPluginManager.registerEvent(event, listener, priority, executor, plugin); return;} // Paper
         registerEvent(event, listener, priority, executor, plugin, false);
     }

@@ -718,6 +755,7 @@ public final class SimplePluginManager implements PluginManager {
      */
     @Override
     public void registerEvent(@NotNull Class<? extends Event> event, @NotNull Listener listener, @NotNull EventPriority priority, @NotNull EventExecutor executor, @NotNull Plugin plugin, boolean ignoreCancelled) {
+        if (true) {this.paperPluginManager.registerEvent(event, listener, priority, executor, plugin, ignoreCancelled); return;} // Paper
         Preconditions.checkArgument(listener != null, "Listener cannot be null");
         Preconditions.checkArgument(priority != null, "Priority cannot be null");
         Preconditions.checkArgument(executor != null, "Executor cannot be null");
@@ -765,16 +803,19 @@ public final class SimplePluginManager implements PluginManager {
     @Override
     @Nullable
     public Permission getPermission(@NotNull String name) {
+        if (true) {return this.paperPluginManager.getPermission(name);} // Paper
         return permissions.get(name.toLowerCase(java.util.Locale.ENGLISH));
     }

     @Override
     public void addPermission(@NotNull Permission perm) {
+        if (true) {this.paperPluginManager.addPermission(perm); return;} // Paper
         addPermission(perm, true);
     }

     @Deprecated
     public void addPermission(@NotNull Permission perm, boolean dirty) {
+        if (true) {this.paperPluginManager.addPermission(perm); return;} // Paper - This just has a performance implication, use the better api to avoid this.
         String name = perm.getName().toLowerCase(java.util.Locale.ENGLISH);

         if (permissions.containsKey(name)) {
@@ -788,21 +829,25 @@ public final class SimplePluginManager implements PluginManager {
     @Override
     @NotNull
     public Set<Permission> getDefaultPermissions(boolean op) {
+        if (true) {return this.paperPluginManager.getDefaultPermissions(op);} // Paper
         return ImmutableSet.copyOf(defaultPerms.get(op));
     }

     @Override
     public void removePermission(@NotNull Permission perm) {
+        if (true) {this.paperPluginManager.removePermission(perm); return;} // Paper
         removePermission(perm.getName());
     }

     @Override
     public void removePermission(@NotNull String name) {
+        if (true) {this.paperPluginManager.removePermission(name); return;} // Paper
         permissions.remove(name.toLowerCase(java.util.Locale.ENGLISH));
     }

     @Override
     public void recalculatePermissionDefaults(@NotNull Permission perm) {
+        if (true) {this.paperPluginManager.recalculatePermissionDefaults(perm); return;} // Paper
         if (perm != null && permissions.containsKey(perm.getName().toLowerCase(java.util.Locale.ENGLISH))) {
             defaultPerms.get(true).remove(perm);
             defaultPerms.get(false).remove(perm);
@@ -842,6 +887,7 @@ public final class SimplePluginManager implements PluginManager {

     @Override
     public void subscribeToPermission(@NotNull String permission, @NotNull Permissible permissible) {
+        if (true) {this.paperPluginManager.subscribeToPermission(permission, permissible); return;} // Paper
         String name = permission.toLowerCase(java.util.Locale.ENGLISH);
         Map<Permissible, Boolean> map = permSubs.get(name);

@@ -855,6 +901,7 @@ public final class SimplePluginManager implements PluginManager {

     @Override
     public void unsubscribeFromPermission(@NotNull String permission, @NotNull Permissible permissible) {
+        if (true) {this.paperPluginManager.unsubscribeFromPermission(permission, permissible); return;} // Paper
         String name = permission.toLowerCase(java.util.Locale.ENGLISH);
         Map<Permissible, Boolean> map = permSubs.get(name);

@@ -870,6 +917,7 @@ public final class SimplePluginManager implements PluginManager {
     @Override
     @NotNull
     public Set<Permissible> getPermissionSubscriptions(@NotNull String permission) {
+        if (true) {return this.paperPluginManager.getPermissionSubscriptions(permission);} // Paper
         String name = permission.toLowerCase(java.util.Locale.ENGLISH);
         Map<Permissible, Boolean> map = permSubs.get(name);

@@ -882,6 +930,7 @@ public final class SimplePluginManager implements PluginManager {

     @Override
     public void subscribeToDefaultPerms(boolean op, @NotNull Permissible permissible) {
+        if (true) {this.paperPluginManager.subscribeToDefaultPerms(op, permissible); return;} // Paper
         Map<Permissible, Boolean> map = defSubs.get(op);

         if (map == null) {
@@ -894,6 +943,7 @@ public final class SimplePluginManager implements PluginManager {

     @Override
     public void unsubscribeFromDefaultPerms(boolean op, @NotNull Permissible permissible) {
+        if (true) {this.paperPluginManager.unsubscribeFromDefaultPerms(op, permissible); return;} // Paper
         Map<Permissible, Boolean> map = defSubs.get(op);

         if (map != null) {
@@ -908,6 +958,7 @@ public final class SimplePluginManager implements PluginManager {
     @Override
     @NotNull
     public Set<Permissible> getDefaultPermSubscriptions(boolean op) {
+        if (true) {return this.paperPluginManager.getDefaultPermSubscriptions(op);} // Paper
         Map<Permissible, Boolean> map = defSubs.get(op);

         if (map == null) {
@@ -920,6 +971,7 @@ public final class SimplePluginManager implements PluginManager {
     @Override
     @NotNull
     public Set<Permission> getPermissions() {
+        if (true) {return this.paperPluginManager.getPermissions();} // Paper
         return new HashSet<Permission>(permissions.values());
     }

@@ -943,6 +995,7 @@ public final class SimplePluginManager implements PluginManager {

     @Override
     public boolean useTimings() {
+        if (true) {return this.paperPluginManager.useTimings();} // Paper
         return co.aikar.timings.Timings.isTimingsEnabled(); // Spigot
     }

@@ -956,11 +1009,28 @@ public final class SimplePluginManager implements PluginManager {
     }

     // Paper start
+
     public void clearPermissions() {
+        if (true) {this.paperPluginManager.clearPermissions(); return;} // Paper
         permissions.clear();
         defaultPerms.get(true).clear();
         defaultPerms.get(false).clear();
     }
     // Paper end
+    // Paper start
+    @Override
+    public boolean isTransitiveDependency(io.papermc.paper.plugin.configuration.PluginConfiguration pluginConfiguration, io.papermc.paper.plugin.configuration.PluginConfiguration dependencyConfig) {
+        return this.paperPluginManager.isTransitiveDependency(pluginConfiguration, dependencyConfig);
+    }

+    @Override
+    public void overridePermissionManager(@Nullable Plugin plugin, @Nullable io.papermc.paper.plugin.PermissionManager permissionManager) {
+        this.paperPluginManager.overridePermissionManager(plugin, permissionManager);
+    }
+
+    @Override
+    public void addPermissions(@NotNull List<Permission> perm) {
+        this.paperPluginManager.addPermissions(perm);
+    }
+    // Paper end
 }
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPlugin.java b/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
index 3bea5dd67ad0393160ccede4ac99a3c7baa1803b..02a1650e450923afaf6c17116c48de54ce102ea9 100644
--- a/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
+++ b/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
@@ -14,6 +14,8 @@ import java.net.URLConnection;
 import java.util.List;
 import java.util.logging.Level;
 import java.util.logging.Logger;
+
+import io.papermc.paper.plugin.configuration.PluginConfiguration;
 import org.bukkit.Server;
 import org.bukkit.command.Command;
 import org.bukkit.command.CommandSender;
@@ -25,7 +27,6 @@ import org.bukkit.generator.ChunkGenerator;
 import org.bukkit.plugin.PluginBase;
 import org.bukkit.plugin.PluginDescriptionFile;
 import org.bukkit.plugin.PluginLoader;
-import org.bukkit.plugin.PluginLogger;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;

@@ -38,28 +39,24 @@ public abstract class JavaPlugin extends PluginBase {
     private Server server = null;
     private File file = null;
     private PluginDescriptionFile description = null;
+    private PluginConfiguration pluginConfiguration = null;
     private File dataFolder = null;
     private ClassLoader classLoader = null;
     private boolean naggable = true;
     private FileConfiguration newConfig = null;
     private File configFile = null;
-    Logger logger = null; // Paper - PluginLogger -> Logger, package-private
+    public Logger logger = null; // Paper - PluginLogger -> Logger, package-private, public

     public JavaPlugin() {
-        final ClassLoader classLoader = this.getClass().getClassLoader();
-        if (!(classLoader instanceof PluginClassLoader)) {
-            throw new IllegalStateException("JavaPlugin requires " + PluginClassLoader.class.getName());
+        // Paper start
+        if (this.getClass().getClassLoader() instanceof io.papermc.paper.plugin.provider.service.classloader.ConfiguredPluginClassLoader configuredPluginClassLoader) {
+            configuredPluginClassLoader.init(this);
+        } else {
+            throw new IllegalStateException("JavaPlugin requires to be created by a valid classloader.");
         }
-        ((PluginClassLoader) classLoader).initialize(this);
     }

-    protected JavaPlugin(@NotNull final JavaPluginLoader loader, @NotNull final PluginDescriptionFile description, @NotNull final File dataFolder, @NotNull final File file) {
-        final ClassLoader classLoader = this.getClass().getClassLoader();
-        if (classLoader instanceof PluginClassLoader) {
-            throw new IllegalStateException("Cannot use initialization constructor at runtime");
-        }
-        init(loader, loader.server, description, dataFolder, file, classLoader);
-    }
+    // Paper - Remove unused constructor that shouldn't be exposed

     /**
      * Returns the folder that the plugin data's files are located in. The
@@ -77,9 +74,12 @@ public abstract class JavaPlugin extends PluginBase {
      * Gets the associated PluginLoader responsible for this plugin
      *
      * @return PluginLoader that controls this plugin
+     * @deprecated Plugin loading now occurs at a point which makes it impossible to expose this
+     * behavior. This instance will only throw unsupported operation exceptions.
      */
     @NotNull
     @Override
+    @Deprecated(forRemoval = true) // Paper
     public final PluginLoader getPluginLoader() {
         return loader;
     }
@@ -120,13 +120,20 @@ public abstract class JavaPlugin extends PluginBase {
      * Returns the plugin.yaml file containing the details for this plugin
      *
      * @return Contents of the plugin.yaml file
+     * @deprecated No longer applicable to all types of plugins
      */
     @NotNull
     @Override
+    @Deprecated
     public final PluginDescriptionFile getDescription() {
         return description;
     }

+    @Nullable
+    public final PluginConfiguration getConfiguration() {
+        return this.pluginConfiguration;
+    }
+
     @NotNull
     @Override
     public FileConfiguration getConfig() {
@@ -256,7 +263,8 @@ public abstract class JavaPlugin extends PluginBase {
      *
      * @param enabled true if enabled, otherwise false
      */
-    protected final void setEnabled(final boolean enabled) {
+    @org.jetbrains.annotations.ApiStatus.Internal // Paper
+    public final void setEnabled(final boolean enabled) { // Paper
         if (isEnabled != enabled) {
             isEnabled = enabled;

@@ -268,9 +276,14 @@ public abstract class JavaPlugin extends PluginBase {
         }
     }

-
-    final void init(@NotNull PluginLoader loader, @NotNull Server server, @NotNull PluginDescriptionFile description, @NotNull File dataFolder, @NotNull File file, @NotNull ClassLoader classLoader) {
-        this.loader = loader;
+    // Paper start
+    public final void init(@NotNull PluginLoader loader, @NotNull Server server, @NotNull PluginDescriptionFile description, @NotNull File dataFolder, @NotNull File file, @NotNull ClassLoader classLoader) {
+        init(server, description, dataFolder, file, classLoader, description);
+        this.pluginConfiguration = description;
+    }
+    public final void init(@NotNull Server server, @NotNull PluginDescriptionFile description, @NotNull File dataFolder, @NotNull File file, @NotNull ClassLoader classLoader, @Nullable PluginConfiguration configuration) {
+    // Paper end
+        this.loader = io.papermc.paper.plugin.UnsupportedBukkitPluginLoader.INSTANCE;
         this.server = server;
         this.file = file;
         this.description = description;
@@ -281,6 +294,7 @@ public abstract class JavaPlugin extends PluginBase {
         if (this.logger == null) {
             this.logger = com.destroystokyo.paper.utils.PaperPluginLogger.getLogger(this.description);
         }
+        this.pluginConfiguration = configuration;
         // Paper end
     }

diff --git a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
index 8ff78fad47f6086aa289e32590f4fbec24b3d500..cbf0129ed98bb2f02ba7f4a3c53cc51593cb2b21 100644
--- a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
@@ -49,6 +49,7 @@ import org.yaml.snakeyaml.error.YAMLException;
 /**
  * Represents a Java plugin loader, allowing plugins in the form of .jar
  */
+@Deprecated(forRemoval = true) // Paper
 public final class JavaPluginLoader implements PluginLoader {
     final Server server;
     private static final boolean DISABLE_CLASS_PRIORITIZATION = Boolean.getBoolean("Paper.DisableClassPrioritization"); // Paper
@@ -150,7 +151,7 @@ public final class JavaPluginLoader implements PluginLoader {

         final PluginClassLoader loader;
         try {
-            loader = new PluginClassLoader(this, getClass().getClassLoader(), description, dataFolder, file, (libraryLoader != null) ? libraryLoader.createLoader(description) : null);
+            loader = new PluginClassLoader(getClass().getClassLoader(), description, dataFolder, file, (libraryLoader != null) ? libraryLoader.createLoader(description) : null); // Paper
         } catch (InvalidPluginException ex) {
             throw ex;
         } catch (Throwable ex) {
diff --git a/src/main/java/org/bukkit/plugin/java/LibraryLoader.java b/src/main/java/org/bukkit/plugin/java/LibraryLoader.java
index 6d634b0ea813ccb19f1562a7d0e5a59cea4eab21..4eec9316e4447701732c944fa84c64a009a5c394 100644
--- a/src/main/java/org/bukkit/plugin/java/LibraryLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/LibraryLoader.java
@@ -36,7 +36,7 @@ import org.eclipse.aether.transport.http.HttpTransporterFactory;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;

-class LibraryLoader
+public class LibraryLoader
 {

     private final Logger logger;
diff --git a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
index 345394132df70593800127d34a38f8f8a4dafe00..5ed7b33acabb2aded6e60751640d0b4a562b798c 100644
--- a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
@@ -20,18 +20,20 @@ import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 import java.util.jar.Manifest;
 import java.util.logging.Level;
+
+import org.bukkit.Bukkit;
+import org.bukkit.configuration.serialization.ConfigurationSerializable;
+import org.bukkit.configuration.serialization.ConfigurationSerialization;
 import org.bukkit.plugin.InvalidPluginException;
 import org.bukkit.plugin.PluginDescriptionFile;
-import org.bukkit.plugin.SimplePluginManager;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;

 /**
  * A ClassLoader for plugins, to allow shared classes across multiple plugins
  */
-public final class PluginClassLoader extends URLClassLoader { // Spigot
+public final class PluginClassLoader extends URLClassLoader implements io.papermc.paper.plugin.provider.service.classloader.ConfiguredPluginClassLoader { // Spigot // Paper
     public JavaPlugin getPlugin() { return plugin; } // Spigot
-    private final JavaPluginLoader loader;
     private final Map<String, Class<?>> classes = new ConcurrentHashMap<String, Class<?>>();
     private final PluginDescriptionFile description; PluginDescriptionFile getDescription() { return description; } // Paper
     private final File dataFolder;
@@ -40,7 +42,7 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
     private final Manifest manifest;
     private final URL url;
     private final ClassLoader libraryLoader;
-    final JavaPlugin plugin;
+    public final JavaPlugin plugin; // Paper
     private JavaPlugin pluginInit;
     private IllegalStateException pluginState;
     private final Set<String> seenIllegalAccess = Collections.newSetFromMap(new ConcurrentHashMap<>());
@@ -50,11 +52,10 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
         ClassLoader.registerAsParallelCapable();
     }

-    PluginClassLoader(@NotNull final JavaPluginLoader loader, @Nullable final ClassLoader parent, @NotNull final PluginDescriptionFile description, @NotNull final File dataFolder, @NotNull final File file, @Nullable ClassLoader libraryLoader) throws IOException, InvalidPluginException, MalformedURLException {
+    public PluginClassLoader(@Nullable final ClassLoader parent, @NotNull final PluginDescriptionFile description, @NotNull final File dataFolder, @NotNull final File file, @Nullable ClassLoader libraryLoader) throws IOException, InvalidPluginException, MalformedURLException { // Paper
         super(file.getName(), new URL[] {file.toURI().toURL()}, parent); // Paper - rewrite LogEvents to contain source jar info
-        Preconditions.checkArgument(loader != null, "Loader cannot be null");
+        // Paper - remove loader

-        this.loader = loader;
         this.description = description;
         this.dataFolder = dataFolder;
         this.file = file;
@@ -97,6 +98,21 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
     public Enumeration<URL> getResources(String name) throws IOException {
         return findResources(name);
     }
+    // Paper start
+    @Override
+    public Class<?> loadClass(@NotNull String name, boolean resolve, boolean checkGlobal, boolean checkLibraries) throws ClassNotFoundException {
+        return this.loadClass0(name, resolve, checkGlobal, checkLibraries);
+    }
+    @Override
+    public io.papermc.paper.plugin.configuration.PluginConfiguration getConfiguration() {
+        return this.description;
+    }
+
+    @Override
+    public void init(JavaPlugin plugin) {
+        this.initialize(plugin);
+    }
+    // Paper end

     @Override
     protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
@@ -123,7 +139,7 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot

         if (checkGlobal) {
             // This ignores the libraries of other plugins, unless they are transitive dependencies.
-            Class<?> result = loader.getClassByName(name, resolve, description, this);  // Paper - prioritize self
+            Class<?> result = io.papermc.paper.plugin.provider.service.classloader.PaperPluginClassLoaderStorage.INSTANCE.getClassByName(name, resolve, description, this);  // Paper - prioritize self

             if (result != null) {
                 // If the class was loaded from a library instead of a PluginClassLoader, we can assume that its associated plugin is a transitive dependency and can therefore skip this check.
@@ -132,14 +148,14 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot

                     if (provider != description
                             && !seenIllegalAccess.contains(provider.getName())
-                            && !((SimplePluginManager) loader.server.getPluginManager()).isTransitiveDepend(description, provider)) {
+                        && !Bukkit.getServer().getPluginManager().isTransitiveDependency(description, provider)) {

                         seenIllegalAccess.add(provider.getName());
                         if (plugin != null) {
                             plugin.getLogger().log(Level.WARNING, "Loaded class {0} from {1} which is not a depend or softdepend of this plugin.", new Object[]{name, provider.getFullName()});
                         } else {
                             // In case the bad access occurs on construction
-                            loader.server.getLogger().log(Level.WARNING, "[{0}] Loaded class {1} from {2} which is not a depend or softdepend of this plugin.", new Object[]{description.getName(), name, provider.getFullName()});
+                            this.logger.log(Level.WARNING, "[{0}] Loaded class {1} from {2} which is not a depend or softdepend of this plugin.", new Object[]{description.getName(), name, provider.getFullName()}); // Paper
                         }
                     }
                 }
@@ -171,7 +187,7 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
                     throw new ClassNotFoundException(name, ex);
                 }

-                classBytes = loader.server.getUnsafe().processClass(description, path, classBytes);
+                classBytes = Bukkit.getServer().getUnsafe().processClass(description, path, classBytes);

                 int dot = name.lastIndexOf('.');
                 if (dot != -1) {
@@ -201,7 +217,6 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
                 result = super.findClass(name);
             }

-            loader.setClass(name, result);
             classes.put(name, result);
         }

@@ -211,6 +226,11 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
     @Override
     public void close() throws IOException {
         try {
+            Collection<Class<?>> classes = getClasses();
+
+            for (Class<?> clazz : classes) {
+                removeClass(clazz);
+            }
             super.close();
         } finally {
             jar.close();
@@ -222,7 +242,7 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
         return classes.values();
     }

-    synchronized void initialize(@NotNull JavaPlugin javaPlugin) {
+    public synchronized void initialize(@NotNull JavaPlugin javaPlugin) { // Paper
         Preconditions.checkArgument(javaPlugin != null, "Initializing plugin cannot be null");
         Preconditions.checkArgument(javaPlugin.getClass().getClassLoader() == this, "Cannot initialize plugin outside of this class loader");
         if (this.plugin != null || this.pluginInit != null) {
@@ -233,7 +253,7 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
         this.pluginInit = javaPlugin;

         javaPlugin.logger = this.logger; // Paper - set logger
-        javaPlugin.init(loader, loader.server, description, dataFolder, file, this);
+        javaPlugin.init(null, Bukkit.getServer(), description, dataFolder, file, this); // Paper
     }

     // Paper start
@@ -246,5 +266,19 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
                    ", url=" + file +
                    '}';
     }
+
+    void setClass(@NotNull final String name, @NotNull final Class<?> clazz) {
+        if (ConfigurationSerializable.class.isAssignableFrom(clazz)) {
+            Class<? extends ConfigurationSerializable> serializable = clazz.asSubclass(ConfigurationSerializable.class);
+            ConfigurationSerialization.registerClass(serializable);
+        }
+    }
+
+    private void removeClass(@NotNull Class<?> clazz) {
+        if (ConfigurationSerializable.class.isAssignableFrom(clazz)) {
+            Class<? extends ConfigurationSerializable> serializable = clazz.asSubclass(ConfigurationSerializable.class);
+            ConfigurationSerialization.unregisterClass(serializable);
+        }
+    }
     // Paper end
 }
diff --git a/src/test/java/org/bukkit/TestServer.java b/src/test/java/org/bukkit/TestServer.java
index 2f907c18c8f3228df107bfc05c5454354e89b943..8be85a159f8bde4b55a06f206424475450c70c0a 100644
--- a/src/test/java/org/bukkit/TestServer.java
+++ b/src/test/java/org/bukkit/TestServer.java
@@ -42,15 +42,7 @@ public final class TestServer implements InvocationHandler {
                 }
             );
             // Paper end
-            methodMap.put(
-                    Server.class.getMethod("getPluginManager"),
-                    new MethodHandler() {
-                        @Override
-                        public Object handle(TestServer server, Object[] args) {
-                            return server.pluginManager;
-                        }
-                    }
-                );
+            // Paper - Remove plugin manager tests
             methodMap.put(
                     Server.class.getMethod("getLogger"),
                     new MethodHandler() {
@@ -114,7 +106,7 @@ public final class TestServer implements InvocationHandler {
             TestServer server = new TestServer();
             Server instance = Proxy.getProxyClass(Server.class.getClassLoader(), Server.class).asSubclass(Server.class).getConstructor(InvocationHandler.class).newInstance(server);
             Bukkit.setServer(instance);
-            server.pluginManager = new SimplePluginManager(instance, new SimpleCommandMap(instance));
+            // Paper - Remove plugin manager tests
         } catch (Throwable t) {
             throw new Error(t);
         }
diff --git a/src/test/java/org/bukkit/event/SyntheticEventTest.java b/src/test/java/org/bukkit/event/SyntheticEventTest.java
deleted file mode 100644
index d402cb59f508205ebe9ee450594826b04cecb90b..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/event/SyntheticEventTest.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package org.bukkit.event;
-
-import org.bukkit.TestServer;
-import org.bukkit.plugin.PluginLoader;
-import org.bukkit.plugin.SimplePluginManager;
-import org.bukkit.plugin.TestPlugin;
-import org.bukkit.plugin.java.JavaPluginLoader;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class SyntheticEventTest {
-    @SuppressWarnings("deprecation")
-    @Test
-    public void test() {
-        final JavaPluginLoader loader = new JavaPluginLoader(TestServer.getInstance());
-        TestPlugin plugin = new TestPlugin(getClass().getName()) {
-            @Override
-            public PluginLoader getPluginLoader() {
-                return loader;
-            }
-        };
-        SimplePluginManager pluginManager = new SimplePluginManager(TestServer.getInstance(), null);
-
-        TestEvent event = new TestEvent(false);
-        Impl impl = new Impl();
-
-        pluginManager.registerEvents(impl, plugin);
-        pluginManager.callEvent(event);
-
-        Assert.assertEquals(1, impl.callCount);
-    }
-
-    public abstract static class Base<E extends Event> implements Listener {
-        int callCount = 0;
-
-        public void accept(E evt) {
-            callCount++;
-        }
-    }
-
-    public static class Impl extends Base<TestEvent> {
-        @Override
-        @EventHandler
-        public void accept(TestEvent evt) {
-            super.accept(evt);
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/plugin/PluginManagerTest.java b/src/test/java/org/bukkit/plugin/PluginManagerTest.java
deleted file mode 100644
index 1941c9f49e9514c1236c5f4ea9f7af47f7be85c5..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/plugin/PluginManagerTest.java
+++ /dev/null
@@ -1,184 +0,0 @@
-package org.bukkit.plugin;
-
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import org.bukkit.TestServer;
-import org.bukkit.event.Event;
-import org.bukkit.event.TestEvent;
-import org.bukkit.permissions.Permission;
-import org.junit.After;
-import org.junit.Test;
-
-public class PluginManagerTest {
-    private class MutableObject {
-        volatile Object value = null;
-    }
-
-    private static final PluginManager pm = TestServer.getInstance().getPluginManager();
-
-    private final MutableObject store = new MutableObject();
-/* // Paper start - remove unneeded test
-    @Test
-    public void testAsyncSameThread() {
-        final Event event = new TestEvent(true);
-        try {
-            pm.callEvent(event);
-        } catch (IllegalStateException ex) {
-            assertThat(event.getEventName() + " cannot be triggered asynchronously from primary server thread.", is(ex.getMessage()));
-            return;
-        }
-        throw new IllegalStateException("No exception thrown");
-    }*/ // Paper end
-
-    @Test
-    public void testSyncSameThread() {
-        final Event event = new TestEvent(false);
-        pm.callEvent(event);
-    }
-/* // Paper start - remove unneeded test
-    @Test
-    public void testAsyncLocked() throws InterruptedException {
-        final Event event = new TestEvent(true);
-        Thread secondThread = new Thread(
-            new Runnable() {
-                @Override
-                public void run() {
-                    try {
-                        synchronized (pm) {
-                            pm.callEvent(event);
-                        }
-                    } catch (Throwable ex) {
-                        store.value = ex;
-                    }
-                }
-            }
-        );
-        secondThread.start();
-        secondThread.join();
-        assertThat(store.value, is(instanceOf(IllegalStateException.class)));
-        assertThat(event.getEventName() + " cannot be triggered asynchronously from inside synchronized code.", is(((Throwable) store.value).getMessage()));
-    }
-
-    @Test
-    public void testAsyncUnlocked() throws InterruptedException {
-        final Event event = new TestEvent(true);
-        Thread secondThread = new Thread(
-            new Runnable() {
-                @Override
-                public void run() {
-                    try {
-                        pm.callEvent(event);
-                    } catch (Throwable ex) {
-                        store.value = ex;
-                    }
-                }
-            }
-        );
-        secondThread.start();
-        secondThread.join();
-        if (store.value != null) {
-            throw new RuntimeException((Throwable) store.value);
-        }
-    }
-
-    @Test
-    public void testSyncUnlocked() throws InterruptedException {
-        final Event event = new TestEvent(false);
-        Thread secondThread = new Thread(
-            new Runnable() {
-                @Override
-                public void run() {
-                    try {
-                        pm.callEvent(event);
-                    } catch (Throwable ex) {
-                        store.value = ex;
-                        assertThat(event.getEventName() + " cannot be triggered asynchronously from another thread.", is(ex.getMessage()));
-                        return;
-                    }
-                }
-            }
-        );
-        secondThread.start();
-        secondThread.join();
-        if (store.value == null) {
-            throw new IllegalStateException("No exception thrown");
-        }
-    }
-
-    @Test
-    public void testSyncLocked() throws InterruptedException {
-        final Event event = new TestEvent(false);
-        Thread secondThread = new Thread(
-            new Runnable() {
-                @Override
-                public void run() {
-                    try {
-                        synchronized (pm) {
-                            pm.callEvent(event);
-                        }
-                    } catch (Throwable ex) {
-                        store.value = ex;
-                        assertThat(event.getEventName() + " cannot be triggered asynchronously from another thread.", is(ex.getMessage()));
-                        return;
-                    }
-                }
-            }
-        );
-        secondThread.start();
-        secondThread.join();
-        if (store.value == null) {
-            throw new IllegalStateException("No exception thrown");
-        }
-    } */ // Paper
-
-    @Test
-    public void testRemovePermissionByNameLower() {
-        this.testRemovePermissionByName("lower");
-    }
-
-    @Test
-    public void testRemovePermissionByNameUpper() {
-        this.testRemovePermissionByName("UPPER");
-    }
-
-    @Test
-    public void testRemovePermissionByNameCamel() {
-        this.testRemovePermissionByName("CaMeL");
-    }
-
-    public void testRemovePermissionByPermissionLower() {
-        this.testRemovePermissionByPermission("lower");
-    }
-
-    @Test
-    public void testRemovePermissionByPermissionUpper() {
-        this.testRemovePermissionByPermission("UPPER");
-    }
-
-    @Test
-    public void testRemovePermissionByPermissionCamel() {
-        this.testRemovePermissionByPermission("CaMeL");
-    }
-
-    private void testRemovePermissionByName(final String name) {
-        final Permission perm = new Permission(name);
-        pm.addPermission(perm);
-        assertThat("Permission \"" + name + "\" was not added", pm.getPermission(name), is(perm));
-        pm.removePermission(name);
-        assertThat("Permission \"" + name + "\" was not removed", pm.getPermission(name), is(nullValue()));
-    }
-
-    private void testRemovePermissionByPermission(final String name) {
-        final Permission perm = new Permission(name);
-        pm.addPermission(perm);
-        assertThat("Permission \"" + name + "\" was not added", pm.getPermission(name), is(perm));
-        pm.removePermission(perm);
-        assertThat("Permission \"" + name + "\" was not removed", pm.getPermission(name), is(nullValue()));
-    }
-
-    @After
-    public void tearDown() {
-        pm.clearPlugins();
-        assertThat(pm.getPermissions(), is(empty()));
-    }
-}
diff --git a/src/test/java/org/bukkit/plugin/TestPlugin.java b/src/test/java/org/bukkit/plugin/TestPlugin.java
index a8be3e23e3e280ad301d9530de50028515612966..ba743beb6f171bfea4fb17ef6858f73bb740f775 100644
--- a/src/test/java/org/bukkit/plugin/TestPlugin.java
+++ b/src/test/java/org/bukkit/plugin/TestPlugin.java
@@ -32,6 +32,12 @@ public class TestPlugin extends PluginBase {
     public PluginDescriptionFile getDescription() {
         return new PluginDescriptionFile(pluginName, "1.0", "test.test");
     }
+    // Paper start
+    @Override
+    public io.papermc.paper.plugin.configuration.PluginConfiguration getConfiguration() {
+        return getDescription();
+    }
+    // Paper end
 
     @Override
     public FileConfiguration getConfig() {
